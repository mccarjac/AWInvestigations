import {
  saveCharacters,
  loadCharacters,
  addCharacter,
  updateCharacter,
  deleteCharacter,
  exportDataset,
  importDataset,
  toggleCharacterPresent,
  resetAllPresentStatus,
  clearStorage,
  saveFactions,
  loadFactions,
  createFaction,
  updateFaction,
  deleteFaction,
  saveLocations,
  loadLocations,
  createLocation,
  updateLocation,
  deleteLocation,
  saveEvents,
  loadEvents,
  createEvent,
  updateEvent,
  deleteEvent,
} from '@/utils/characterStorage';
import * as CharacterStorage from '@/utils/characterStorage';
import { SafeAsyncStorageJSONParser } from '@/utils/safeAsyncStorageJSONParser';
import {
  GameCharacter,
  GameLocation,
  GameEvent,
  RelationshipStanding,
} from '@/models/types';

// Mock the SafeAsyncStorageJSONParser
jest.mock('@/utils/safeAsyncStorageJSONParser');

// Mock uuid
jest.mock('uuid', () => ({
  v4: jest.fn(() => 'mock-uuid-1234'),
}));

describe('characterStorage', () => {
  const mockDate = '2025-01-01T00:00:00.000Z';

  beforeEach(() => {
    jest.clearAllMocks();
    jest.spyOn(Date.prototype, 'toISOString').mockReturnValue(mockDate);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Character CRUD Operations', () => {
    const mockCharacter: GameCharacter = {
      id: 'char-1',
      name: 'Test Character',
      species: 'Human',
      perkIds: ['perk1'],
      distinctionIds: ['dist1'],
      factions: [{ name: 'Brotherhood', standing: RelationshipStanding.Ally }],
      relationships: [],
      present: false,
      retired: false,
      createdAt: mockDate,
      updatedAt: mockDate,
    };

    describe('loadCharacters', () => {
      it('should return empty array when no data exists', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue(
          null
        );

        const result = await loadCharacters();

        expect(result).toEqual([]);
      });

      it('should return characters from storage', async () => {
        const mockDataset = {
          characters: [mockCharacter],
          version: '1.0',
          lastUpdated: mockDate,
        };
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue(
          mockDataset
        );

        const result = await loadCharacters();

        expect(result).toEqual([mockCharacter]);
        expect(SafeAsyncStorageJSONParser.getItem).toHaveBeenCalledWith(
          'gameCharacterManager'
        );
      });

      it('should apply backward compatibility defaults', async () => {
        const oldCharacter = {
          id: 'char-1',
          name: 'Old Character',
          species: 'Human',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          createdAt: mockDate,
          updatedAt: mockDate,
        };
        const mockDataset = {
          characters: [oldCharacter],
          version: '1.0',
          lastUpdated: mockDate,
        };
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue(
          mockDataset
        );

        const result = await loadCharacters();

        expect(result[0].present).toBe(false);
        expect(result[0].retired).toBe(false);
        expect(result[0].relationships).toEqual([]);
      });

      it('should return empty array when dataset has no characters property', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await loadCharacters();

        expect(result).toEqual([]);
      });
    });

    describe('saveCharacters', () => {
      it('should save characters with proper dataset structure', async () => {
        const characters = [mockCharacter];

        await saveCharacters(characters);

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager',
          {
            characters,
            version: '1.0',
            lastUpdated: mockDate,
          }
        );
      });

      it('should save empty array', async () => {
        await saveCharacters([]);

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager',
          {
            characters: [],
            version: '1.0',
            lastUpdated: mockDate,
          }
        );
      });
    });

    describe('addCharacter', () => {
      it('should add a new character with generated ID and timestamps', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          characters: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const newCharacterData = {
          name: 'New Character',
          species: 'Mutant' as const,
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
        };

        const result = await addCharacter(newCharacterData);

        expect(result.id).toBe('mock-uuid-1234');
        expect(result.name).toBe('New Character');
        expect(result.present).toBe(false);
        expect(result.retired).toBe(false);
        expect(result.createdAt).toBe(mockDate);
        expect(result.updatedAt).toBe(mockDate);
      });

      it('should add character to existing list', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          characters: [mockCharacter],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const newCharacterData = {
          name: 'Second Character',
          species: 'Android' as const,
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
        };

        await addCharacter(newCharacterData);

        const savedData = (SafeAsyncStorageJSONParser.setItem as jest.Mock).mock
          .calls[0][1];
        expect(savedData.characters).toHaveLength(2);
        expect(savedData.characters[0]).toEqual(mockCharacter);
        expect(savedData.characters[1].name).toBe('Second Character');
      });

      it('should ensure relationships array exists', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          characters: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const newCharacterData = {
          name: 'Character Without Relationships',
          species: 'Human' as const,
          perkIds: [],
          distinctionIds: [],
          factions: [],
        } as any;

        const result = await addCharacter(newCharacterData);

        expect(result.relationships).toEqual([]);
      });
    });

    describe('updateCharacter', () => {
      it('should update existing character', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          characters: [mockCharacter],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const updates = {
          name: 'Updated Name',
          present: true,
        };

        const result = await updateCharacter('char-1', updates);

        expect(result).not.toBeNull();
        expect(result?.name).toBe('Updated Name');
        expect(result?.present).toBe(true);
        expect(result?.updatedAt).toBe(mockDate);
      });

      it('should return null for non-existent character', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          characters: [mockCharacter],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await updateCharacter('non-existent-id', {
          name: 'New Name',
        });

        expect(result).toBeNull();
      });

      it('should preserve unchanged properties', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          characters: [mockCharacter],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await updateCharacter('char-1', { retired: true });

        expect(result?.name).toBe('Test Character');
        expect(result?.species).toBe('Human');
        expect(result?.retired).toBe(true);
      });
    });

    describe('deleteCharacter', () => {
      it('should delete existing character', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          characters: [mockCharacter],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await deleteCharacter('char-1');

        expect(result).toBe(true);
        const savedData = (SafeAsyncStorageJSONParser.setItem as jest.Mock).mock
          .calls[0][1];
        expect(savedData.characters).toHaveLength(0);
      });

      it('should return false for non-existent character', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          characters: [mockCharacter],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await deleteCharacter('non-existent-id');

        expect(result).toBe(false);
      });

      it('should delete only the specified character', async () => {
        const character2 = { ...mockCharacter, id: 'char-2', name: 'Char 2' };
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          characters: [mockCharacter, character2],
          version: '1.0',
          lastUpdated: mockDate,
        });

        await deleteCharacter('char-1');

        const savedData = (SafeAsyncStorageJSONParser.setItem as jest.Mock).mock
          .calls[0][1];
        expect(savedData.characters).toHaveLength(1);
        expect(savedData.characters[0].id).toBe('char-2');
      });
    });

    describe('toggleCharacterPresent', () => {
      it('should toggle present status from false to true', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          characters: [mockCharacter],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await toggleCharacterPresent('char-1');

        expect(result).not.toBeNull();
        expect(result?.present).toBe(true);
        const savedData = (SafeAsyncStorageJSONParser.setItem as jest.Mock).mock
          .calls[0][1];
        expect(savedData.characters[0].present).toBe(true);
      });

      it('should toggle present status from true to false', async () => {
        const presentCharacter = { ...mockCharacter, present: true };
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          characters: [presentCharacter],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await toggleCharacterPresent('char-1');

        expect(result).not.toBeNull();
        expect(result?.present).toBe(false);
        const savedData = (SafeAsyncStorageJSONParser.setItem as jest.Mock).mock
          .calls[0][1];
        expect(savedData.characters[0].present).toBe(false);
      });

      it('should return null for non-existent character', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          characters: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await toggleCharacterPresent('non-existent');

        expect(result).toBeNull();
      });
    });

    describe('resetAllPresentStatus', () => {
      it('should set all characters present to false', async () => {
        const char1 = { ...mockCharacter, id: 'char-1', present: true };
        const char2 = { ...mockCharacter, id: 'char-2', present: true };
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          characters: [char1, char2],
          version: '1.0',
          lastUpdated: mockDate,
        });

        await resetAllPresentStatus();

        const savedData = (SafeAsyncStorageJSONParser.setItem as jest.Mock).mock
          .calls[0][1];
        expect(savedData.characters[0].present).toBe(false);
        expect(savedData.characters[1].present).toBe(false);
      });

      it('should handle empty character list', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          characters: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        await resetAllPresentStatus();

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalled();
      });
    });
  });

  describe('Data Import/Export', () => {
    describe('exportDataset', () => {
      it('should export all data types', async () => {
        const mockCharacters = {
          characters: [
            {
              id: 'char-1',
              name: 'Test',
              species: 'Human',
              perkIds: [],
              distinctionIds: [],
              factions: [],
              relationships: [],
              createdAt: mockDate,
              updatedAt: mockDate,
            },
          ],
          version: '1.0',
          lastUpdated: mockDate,
        };
        const mockFactions = {
          factions: [
            {
              name: 'TestFaction',
              description: 'Test',
              createdAt: mockDate,
              updatedAt: mockDate,
            },
          ],
          version: '1.0',
          lastUpdated: mockDate,
        };
        const mockLocations = {
          locations: [
            {
              id: 'loc-1',
              name: 'TestLocation',
              description: 'Test',
              createdAt: mockDate,
              updatedAt: mockDate,
            },
          ],
          version: '1.0',
          lastUpdated: mockDate,
        };
        const mockEvents = {
          events: [
            {
              id: 'event-1',
              name: 'TestEvent',
              description: 'Test',
              date: mockDate,
              createdAt: mockDate,
              updatedAt: mockDate,
            },
          ],
          version: '1.0',
          lastUpdated: mockDate,
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock)
          .mockResolvedValueOnce(mockCharacters)
          .mockResolvedValueOnce(mockFactions)
          .mockResolvedValueOnce(mockLocations)
          .mockResolvedValueOnce(mockEvents);

        const result = await exportDataset();
        const parsed = JSON.parse(result);

        expect(parsed.characters).toHaveLength(1);
        expect(parsed.factions).toHaveLength(1);
        expect(parsed.locations).toHaveLength(1);
        expect(parsed.events).toHaveLength(1);
        expect(parsed.version).toBe('1.0');
      });

      it('should handle missing data gracefully', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue(
          null
        );

        const result = await exportDataset();
        const parsed = JSON.parse(result);

        expect(parsed.characters).toEqual([]);
        expect(parsed.factions).toEqual([]);
        expect(parsed.locations).toEqual([]);
        expect(parsed.events).toEqual([]);
      });
    });

    describe('importDataset', () => {
      it('should import valid dataset', async () => {
        const dataset = {
          characters: [
            {
              id: 'char-1',
              name: 'Imported',
              species: 'Human',
              perkIds: [],
              distinctionIds: [],
              factions: [],
              relationships: [],
              createdAt: mockDate,
              updatedAt: mockDate,
            },
          ],
          factions: [
            {
              name: 'ImportedFaction',
              description: 'Test',
              createdAt: mockDate,
              updatedAt: mockDate,
            },
          ],
          locations: [],
          events: [],
          version: '1.0',
          lastUpdated: mockDate,
        };

        // Mock loadLocations to return empty array
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          locations: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await importDataset(JSON.stringify(dataset));

        expect(result).toBe(true);
        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalled();
      });

      it('should return false for invalid JSON', async () => {
        const result = await importDataset('invalid-json{');

        expect(result).toBe(false);
      });

      it('should handle dataset without optional fields', async () => {
        const minimalDataset = {
          characters: [],
          version: '1.0',
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          locations: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await importDataset(JSON.stringify(minimalDataset));

        expect(result).toBe(true);
      });
    });
  });

  describe('Faction Operations', () => {
    const mockFaction = {
      name: 'Brotherhood',
      description: 'Test faction',
      createdAt: mockDate,
      updatedAt: mockDate,
    };

    describe('loadFactions', () => {
      it('should return empty array when no factions exist', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue(
          null
        );

        const result = await loadFactions();

        expect(result).toEqual([]);
      });

      it('should return factions from storage', async () => {
        const mockDataset = {
          factions: [mockFaction],
          version: '1.0',
          lastUpdated: mockDate,
        };
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue(
          mockDataset
        );

        const result = await loadFactions();

        expect(result).toHaveLength(1);
        expect(result[0].name).toBe('Brotherhood');
        expect(result[0].description).toBe('Test faction');
      });

      it('should apply backward compatibility defaults', async () => {
        const oldFaction = {
          name: 'OldFaction',
          description: 'Test',
          createdAt: mockDate,
          updatedAt: mockDate,
        };
        const mockDataset = {
          factions: [oldFaction],
          version: '1.0',
          lastUpdated: mockDate,
        };
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue(
          mockDataset
        );

        const result = await loadFactions();

        expect(result[0].retired).toBe(false);
      });
    });

    describe('saveFactions', () => {
      it('should save factions with proper dataset structure', async () => {
        const factions = [mockFaction];

        await saveFactions(factions);

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_factions',
          {
            factions,
            version: '1.0',
            lastUpdated: mockDate,
          }
        );
      });
    });

    describe('createFaction', () => {
      it('should create a new faction', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const newFactionData = {
          name: 'New Faction',
          description: 'New faction description',
        };

        const result = await createFaction(newFactionData);

        expect(result).toBe(true);
        const savedData = (SafeAsyncStorageJSONParser.setItem as jest.Mock).mock
          .calls[0][1];
        expect(savedData.factions[0].name).toBe('New Faction');
        expect(savedData.factions[0].description).toBe(
          'New faction description'
        );
      });

      it('should add faction to existing list', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [mockFaction],
          version: '1.0',
          lastUpdated: mockDate,
        });

        await createFaction({ name: 'Second Faction', description: 'Test' });

        const savedData = (SafeAsyncStorageJSONParser.setItem as jest.Mock).mock
          .calls[0][1];
        expect(savedData.factions).toHaveLength(2);
      });
    });

    describe('updateFaction', () => {
      it('should update existing faction', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [mockFaction],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await updateFaction('Brotherhood', {
          description: 'Updated description',
        });

        expect(result).not.toBeNull();
        expect(result?.description).toBe('Updated description');
      });

      it('should return null for non-existent faction', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [mockFaction],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await updateFaction('NonExistent', {
          description: 'Test',
        });

        expect(result).toBeNull();
      });
    });

    describe('deleteFaction', () => {
      it('should delete existing faction', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [mockFaction],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await deleteFaction('Brotherhood');

        expect(result).toBe(true);
        const savedData = (SafeAsyncStorageJSONParser.setItem as jest.Mock).mock
          .calls[0][1];
        expect(savedData.factions).toHaveLength(0);
      });

      it('should return false for non-existent faction', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await deleteFaction('NonExistent');

        expect(result).toBe(false);
      });
    });
  });

  describe('Location Operations', () => {
    const mockLocation: GameLocation = {
      id: 'loc-1',
      name: 'Test Location',
      description: 'Test location description',
      createdAt: mockDate,
      updatedAt: mockDate,
    };

    describe('loadLocations', () => {
      it('should return empty array when no locations exist', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue(
          null
        );

        const result = await loadLocations();

        expect(result).toEqual([]);
      });

      it('should return locations from storage', async () => {
        const mockDataset = {
          locations: [mockLocation],
          version: '1.0',
          lastUpdated: mockDate,
        };
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue(
          mockDataset
        );

        const result = await loadLocations();

        expect(result).toEqual([mockLocation]);
      });
    });

    describe('saveLocations', () => {
      it('should save locations with proper dataset structure', async () => {
        const locations = [mockLocation];

        await saveLocations(locations);

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_locations',
          {
            locations,
            version: '1.0',
            lastUpdated: mockDate,
          }
        );
      });
    });

    describe('createLocation', () => {
      it('should create a new location with generated ID', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          locations: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const newLocationData = {
          name: 'New Location',
          description: 'New location description',
        };

        const result = await createLocation(newLocationData);

        expect(result).not.toBeNull();
        expect(result?.id).toBe('mock-uuid-1234');
        expect(result?.name).toBe('New Location');
        expect(result?.createdAt).toBe(mockDate);
        expect(result?.updatedAt).toBe(mockDate);
      });
    });

    describe('updateLocation', () => {
      it('should update existing location', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          locations: [mockLocation],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await updateLocation('loc-1', {
          name: 'Updated Location',
        });

        expect(result).not.toBeNull();
        expect(result?.name).toBe('Updated Location');
      });

      it('should return null for non-existent location', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          locations: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await updateLocation('non-existent', { name: 'Test' });

        expect(result).toBeNull();
      });
    });

    describe('deleteLocation', () => {
      it('should delete existing location', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          locations: [mockLocation],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await deleteLocation('loc-1');

        expect(result).toBe(true);
      });

      it('should return false for non-existent location', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          locations: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await deleteLocation('non-existent');

        expect(result).toBe(false);
      });
    });
  });

  describe('Event Operations', () => {
    const mockEvent: GameEvent = {
      id: 'event-1',
      title: 'Test Event',
      description: 'Test event description',
      date: mockDate,
      createdAt: mockDate,
      updatedAt: mockDate,
    };

    describe('loadEvents', () => {
      it('should return empty array when no events exist', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue(
          null
        );

        const result = await loadEvents();

        expect(result).toEqual([]);
      });

      it('should return events from storage', async () => {
        const mockDataset = {
          events: [mockEvent],
          version: '1.0',
          lastUpdated: mockDate,
        };
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue(
          mockDataset
        );

        const result = await loadEvents();

        expect(result).toEqual([mockEvent]);
      });
    });

    describe('saveEvents', () => {
      it('should save events with proper dataset structure', async () => {
        const events = [mockEvent];

        await saveEvents(events);

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_events',
          {
            events,
            version: '1.0',
            lastUpdated: mockDate,
          }
        );
      });
    });

    describe('createEvent', () => {
      it('should create a new event with generated ID', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          events: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const newEventData = {
          title: 'New Event',
          description: 'New event description',
          date: mockDate,
        };

        const result = await createEvent(newEventData);

        expect(result).not.toBeNull();
        expect(result?.id).toBe('mock-uuid-1234');
        expect(result?.title).toBe('New Event');
        expect(result?.createdAt).toBe(mockDate);
        expect(result?.updatedAt).toBe(mockDate);
      });
    });

    describe('updateEvent', () => {
      it('should update existing event', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          events: [mockEvent],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await updateEvent('event-1', { title: 'Updated Event' });

        expect(result).not.toBeNull();
        expect(result?.title).toBe('Updated Event');
      });

      it('should return null for non-existent event', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          events: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await updateEvent('non-existent', { title: 'Test' });

        expect(result).toBeNull();
      });
    });

    describe('deleteEvent', () => {
      it('should delete existing event', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          events: [mockEvent],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await deleteEvent('event-1');

        expect(result).toBe(true);
      });

      it('should return false for non-existent event', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          events: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        const result = await deleteEvent('non-existent');

        expect(result).toBe(false);
      });
    });
  });

  describe('Storage Management', () => {
    describe('clearStorage', () => {
      it('should remove all storage keys', async () => {
        await clearStorage();

        expect(SafeAsyncStorageJSONParser.removeItem).toHaveBeenCalledTimes(4);
        expect(SafeAsyncStorageJSONParser.removeItem).toHaveBeenCalledWith(
          'gameCharacterManager'
        );
        expect(SafeAsyncStorageJSONParser.removeItem).toHaveBeenCalledWith(
          'gameCharacterManager_factions'
        );
        expect(SafeAsyncStorageJSONParser.removeItem).toHaveBeenCalledWith(
          'gameCharacterManager_locations'
        );
        expect(SafeAsyncStorageJSONParser.removeItem).toHaveBeenCalledWith(
          'gameCharacterManager_events'
        );
      });
    });
  });

  describe('Advanced Import/Export Features', () => {
    const {
      mergeDatasets,
      mergeDatasetWithConflictResolution,
      getFactionDescription,
      saveFactionDescription,
      deleteFactionCompletely,
      deleteLocationCompletely,
      migrateFactionDescriptions,
      toggleFactionRetired,
      getAllStoredFactions,
    } = CharacterStorage;

    describe('importDataset with old location migration', () => {
      it('should migrate old location field to locationId and create new location', async () => {
        const oldCharacter = {
          id: 'char-1',
          name: 'Test Character',
          species: 'Human',
          location: 'Old Town',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          locations: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        await migrateOldLocationData([oldCharacter]);

        expect((oldCharacter as any).locationId).toBe('mock-uuid-1234');
        expect((oldCharacter as any).location).toBeUndefined();
        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_locations',
          expect.objectContaining({
            locations: expect.arrayContaining([
              expect.objectContaining({
                id: 'mock-uuid-1234',
                name: 'Old Town',
                description: 'Migrated from old location data: Old Town',
              }),
            ]),
          })
        );
      });

      it('should reuse existing location when name matches', async () => {
        const existingLocation: GameLocation = {
          id: 'existing-loc-id',
          name: 'Old Town',
          description: 'Existing location',
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        const oldCharacter = {
          id: 'char-1',
          name: 'Test Character',
          species: 'Human',
          location: 'Old Town',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          locations: [existingLocation],
          version: '1.0',
          lastUpdated: mockDate,
        });

        await migrateOldLocationData([oldCharacter]);

        expect((oldCharacter as any).locationId).toBe('existing-loc-id');
        expect((oldCharacter as any).location).toBeUndefined();
      });

      it('should not create locations for characters without old location field', async () => {
        const character: GameCharacter = {
          id: 'char-1',
          name: 'Test Character',
          species: 'Human',
          locationId: 'existing-id',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          locations: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        await migrateOldLocationData([character]);

        // Should not save any new locations
        expect(SafeAsyncStorageJSONParser.setItem).not.toHaveBeenCalled();
      });
    });

    describe('ensureLocationsExist', () => {
      it('should create placeholder locations for missing locationIds', async () => {
        const character: GameCharacter = {
          id: 'char-1',
          name: 'Test Character',
          species: 'Human',
          locationId: 'missing-location-id',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          locations: [],
          version: '1.0',
          lastUpdated: mockDate,
        });

        await ensureLocationsExist([character]);

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_locations',
          expect.objectContaining({
            locations: expect.arrayContaining([
              expect.objectContaining({
                id: 'missing-location-id',
                name: 'Imported Location (missing-l)',
                description:
                  'This location was automatically created during import. Please update the name and description.',
              }),
            ]),
          })
        );
      });

      it('should not create locations that already exist', async () => {
        const existingLocation: GameLocation = {
          id: 'existing-id',
          name: 'Existing Location',
          description: 'Already exists',
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        const character: GameCharacter = {
          id: 'char-1',
          name: 'Test Character',
          species: 'Human',
          locationId: 'existing-id',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          locations: [existingLocation],
          version: '1.0',
          lastUpdated: mockDate,
        });

        await ensureLocationsExist([character]);

        // Should not create any new locations
        expect(SafeAsyncStorageJSONParser.setItem).not.toHaveBeenCalled();
      });
    });

    describe('mergeCharacterProperties', () => {
      it('should merge arrays (perkIds, distinctionIds, factions)', async () => {
        const existing: GameCharacter = {
          id: 'char-1',
          name: 'Test',
          species: 'Human',
          perkIds: ['perk1'],
          distinctionIds: ['dist1'],
          factions: [
            { name: 'Faction A', standing: RelationshipStanding.Ally },
          ],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        const imported: GameCharacter = {
          id: 'char-1',
          name: 'Test',
          species: 'Human',
          perkIds: ['perk2'],
          distinctionIds: ['dist2'],
          factions: [
            { name: 'Faction B', standing: RelationshipStanding.Neutral },
          ],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        const result = mergeCharacterProperties(existing, imported);

        expect(result.merged.perkIds).toEqual(['perk1', 'perk2']);
        expect(result.merged.distinctionIds).toEqual(['dist1', 'dist2']);
        expect(result.merged.factions).toHaveLength(2);
        expect(result.conflicts).toEqual([]);
      });

      it('should detect conflicts in simple properties', async () => {
        const existing: GameCharacter = {
          id: 'char-1',
          name: 'Original Name',
          species: 'Human',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        const imported: GameCharacter = {
          id: 'char-1',
          name: 'Different Name',
          species: 'Mutant',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        const result = mergeCharacterProperties(existing, imported);

        expect(result.conflicts).toContain('name');
        expect(result.conflicts).toContain('species');
      });

      it('should use imported value when existing is empty', async () => {
        const existing: GameCharacter = {
          id: 'char-1',
          name: '',
          species: 'Human',
          notes: '',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        const imported: GameCharacter = {
          id: 'char-1',
          name: 'Imported Name',
          species: 'Human',
          notes: 'Imported notes',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        const result = mergeCharacterProperties(existing, imported);

        expect(result.merged.name).toBe('Imported Name');
        expect(result.merged.notes).toBe('Imported notes');
        expect(result.conflicts).toEqual([]);
      });

      it('should merge and update relationships', async () => {
        const existing: GameCharacter = {
          id: 'char-1',
          name: 'Test',
          species: 'Human',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [
            {
              characterName: 'Character A',
              relationshipType: RelationshipStanding.Friend,
              description: 'Old description',
            },
          ],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        const imported: GameCharacter = {
          id: 'char-1',
          name: 'Test',
          species: 'Human',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [
            {
              characterName: 'Character A',
              relationshipType: RelationshipStanding.Ally,
              description: 'New description',
            },
            {
              characterName: 'Character B',
              relationshipType: RelationshipStanding.Enemy,
              description: 'New relationship',
            },
          ],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        const result = mergeCharacterProperties(existing, imported);

        expect(result.merged.relationships).toHaveLength(2);
        expect(result.merged.relationships[0].relationshipType).toBe(
          RelationshipStanding.Ally
        );
        expect(result.merged.relationships[0].description).toBe(
          'New description'
        );
      });

      it('should ensure relationships array exists even when empty', async () => {
        const existing: GameCharacter = {
          id: 'char-1',
          name: 'Test',
          species: 'Human',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        } as any;

        const imported: GameCharacter = {
          id: 'char-1',
          name: 'Test',
          species: 'Human',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        } as any;

        const result = mergeCharacterProperties(existing, imported);

        expect(result.merged.relationships).toEqual([]);
      });
    });

    describe('mergeDatasets', () => {
      it('should merge datasets with location migration and updates', async () => {
        const existingCharacter: GameCharacter = {
          id: 'char-1',
          name: 'Existing',
          species: 'Human',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        const importedCharacter: GameCharacter = {
          id: 'char-2',
          name: 'Imported',
          species: 'Mutant',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        const importedLocation: GameLocation = {
          id: 'loc-1',
          name: 'New Location',
          description: 'Imported location',
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock)
          .mockResolvedValueOnce({
            characters: [existingCharacter],
            version: '1.0',
            lastUpdated: mockDate,
          })
          .mockResolvedValueOnce({ factions: [], version: '1.0' })
          .mockResolvedValueOnce({ locations: [], version: '1.0' })
          .mockResolvedValueOnce({ locations: [], version: '1.0' });

        const jsonData = JSON.stringify({
          characters: [importedCharacter],
          factions: [],
          locations: [importedLocation],
        });

        const result = await mergeDatasets(jsonData);

        expect(result).toBe(true);
        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager',
          expect.objectContaining({
            characters: expect.arrayContaining([
              existingCharacter,
              importedCharacter,
            ]),
          })
        );
      });

      it('should update existing locations with newer imported data', async () => {
        const oldLocation: GameLocation = {
          id: 'loc-1',
          name: 'Old Location',
          description: 'Old description',
          createdAt: mockDate,
          updatedAt: '2024-01-01T00:00:00.000Z',
        };

        const newLocation: GameLocation = {
          id: 'loc-1',
          name: 'Updated Location',
          description: 'New description',
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock)
          .mockResolvedValueOnce({
            characters: [],
            version: '1.0',
            lastUpdated: mockDate,
          })
          .mockResolvedValueOnce({ factions: [], version: '1.0' })
          .mockResolvedValueOnce({ locations: [], version: '1.0' })
          .mockResolvedValueOnce({
            locations: [oldLocation],
            version: '1.0',
          });

        const jsonData = JSON.stringify({
          characters: [],
          factions: [],
          locations: [newLocation],
        });

        await mergeDatasets(jsonData);

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_locations',
          expect.objectContaining({
            locations: [newLocation],
          })
        );
      });

      it('should return false on error', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockRejectedValue(
          new Error('Storage error')
        );

        const result = await mergeDatasets('{}');

        expect(result).toBe(false);
      });
    });

    describe('mergeDatasetWithConflictResolution', () => {
      it('should return conflicts when merging characters with different properties', async () => {
        const existing: GameCharacter = {
          id: 'char-1',
          name: 'Original Name',
          species: 'Human',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        const imported: GameCharacter = {
          id: 'char-1',
          name: 'Conflicting Name',
          species: 'Mutant',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock)
          .mockResolvedValueOnce({
            characters: [existing],
            version: '1.0',
            lastUpdated: mockDate,
          })
          .mockResolvedValueOnce({ factions: [], version: '1.0' })
          .mockResolvedValueOnce({ locations: [], version: '1.0' })
          .mockResolvedValueOnce({ locations: [], version: '1.0' });

        const jsonData = JSON.stringify({
          characters: [imported],
          factions: [],
          locations: [],
        });

        const result = await mergeDatasetWithConflictResolution(jsonData);

        expect(result.success).toBe(true);
        expect(result.conflicts).toHaveLength(1);
        expect(result.conflicts[0].id).toBe('char-1');
        expect(result.conflicts[0].conflicts).toContain('name');
        expect(result.conflicts[0].conflicts).toContain('species');
      });

      it('should add new characters without conflicts', async () => {
        const imported: GameCharacter = {
          id: 'char-2',
          name: 'New Character',
          species: 'Unturned',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock)
          .mockResolvedValueOnce({
            characters: [],
            version: '1.0',
            lastUpdated: mockDate,
          })
          .mockResolvedValueOnce({ factions: [], version: '1.0' })
          .mockResolvedValueOnce({ locations: [], version: '1.0' })
          .mockResolvedValueOnce({ locations: [], version: '1.0' });

        const jsonData = JSON.stringify({
          characters: [imported],
          factions: [],
          locations: [],
        });

        const result = await mergeDatasetWithConflictResolution(jsonData);

        expect(result.success).toBe(true);
        expect(result.conflicts).toHaveLength(0);
        expect(result.added).toHaveLength(1);
        expect(result.added[0].id).toBe('char-2');
      });

      it('should return error result on failure', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockRejectedValue(
          new Error('Storage error')
        );

        const result = await mergeDatasetWithConflictResolution('{}');

        expect(result.success).toBe(false);
        expect(result.conflicts).toEqual([]);
        expect(result.merged).toEqual([]);
        expect(result.added).toEqual([]);
      });
    });

    describe('Faction Description Management', () => {
      it('should get faction description', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [
            { name: 'Brotherhood', description: 'A powerful faction' },
          ],
          version: '1.0',
        });

        const result = await getFactionDescription('Brotherhood');

        expect(result).toBe('A powerful faction');
      });

      it('should return empty string for non-existent faction', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [],
          version: '1.0',
        });

        const result = await getFactionDescription('NonExistent');

        expect(result).toBe('');
      });

      it('should save faction description for existing faction', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [{ name: 'Brotherhood', description: 'Old description' }],
          version: '1.0',
        });

        await saveFactionDescription('Brotherhood', 'New description');

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_factions',
          expect.objectContaining({
            factions: [
              expect.objectContaining({
                name: 'Brotherhood',
                description: 'New description',
              }),
            ],
          })
        );
      });

      it('should create new faction when saving description for non-existent faction', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [],
          version: '1.0',
        });

        await saveFactionDescription('NewFaction', 'New description');

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_factions',
          expect.objectContaining({
            factions: [
              expect.objectContaining({
                name: 'NewFaction',
                description: 'New description',
              }),
            ],
          })
        );
      });
    });

    describe('deleteFactionCompletely', () => {
      it('should remove faction from all characters and delete faction', async () => {
        const characterWithFaction: GameCharacter = {
          id: 'char-1',
          name: 'Test',
          species: 'Human',
          perkIds: [],
          distinctionIds: [],
          factions: [
            { name: 'ToDelete', standing: RelationshipStanding.Ally },
            { name: 'ToKeep', standing: RelationshipStanding.Neutral },
          ],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock)
          .mockResolvedValueOnce({
            characters: [characterWithFaction],
            version: '1.0',
            lastUpdated: mockDate,
          })
          .mockResolvedValueOnce({
            factions: [
              { name: 'ToDelete', description: 'Will be deleted' },
              { name: 'ToKeep', description: 'Will be kept' },
            ],
            version: '1.0',
          });

        const result = await deleteFactionCompletely('ToDelete');

        expect(result.success).toBe(true);
        expect(result.charactersUpdated).toBe(1);
        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager',
          expect.objectContaining({
            characters: [
              expect.objectContaining({
                factions: [
                  { name: 'ToKeep', standing: RelationshipStanding.Neutral },
                ],
              }),
            ],
          })
        );
      });

      it('should return error on failure', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockRejectedValue(
          new Error('Storage error')
        );

        const result = await deleteFactionCompletely('ToDelete');

        expect(result.success).toBe(false);
        expect(result.charactersUpdated).toBe(0);
      });
    });

    describe('Faction Bidirectional Relationships', () => {
      it('should create bidirectional relationships when creating faction', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [{ name: 'ExistingFaction', relationships: [] }],
          version: '1.0',
        });

        const newFaction = {
          name: 'NewFaction',
          description: 'Test',
          relationships: [
            {
              factionName: 'ExistingFaction',
              relationshipType: RelationshipStanding.Ally,
            },
          ],
        };

        await createFaction(newFaction);

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_factions',
          expect.objectContaining({
            factions: expect.arrayContaining([
              expect.objectContaining({
                name: 'ExistingFaction',
                relationships: [
                  {
                    factionName: 'NewFaction',
                    relationshipType: RelationshipStanding.Ally,
                  },
                ],
              }),
            ]),
          })
        );
      });

      it('should handle faction name changes and update all references', async () => {
        const faction1 = {
          name: 'OldName',
          description: 'Test',
          relationships: [],
        };
        const faction2 = {
          name: 'OtherFaction',
          description: 'Other',
          relationships: [
            {
              factionName: 'OldName',
              relationshipType: RelationshipStanding.Ally,
            },
          ],
        };

        const character: GameCharacter = {
          id: 'char-1',
          name: 'Test',
          species: 'Human',
          perkIds: [],
          distinctionIds: [],
          factions: [{ name: 'OldName', standing: RelationshipStanding.Ally }],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock)
          .mockResolvedValueOnce({
            factions: [faction1, faction2],
            version: '1.0',
          })
          .mockResolvedValueOnce({
            characters: [character],
            version: '1.0',
            lastUpdated: mockDate,
          });

        const result = await updateFaction('OldName', { name: 'NewName' });

        expect(result?.name).toBe('NewName');
        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager',
          expect.objectContaining({
            characters: [
              expect.objectContaining({
                factions: [
                  { name: 'NewName', standing: RelationshipStanding.Ally },
                ],
              }),
            ],
          })
        );
        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_factions',
          expect.objectContaining({
            factions: expect.arrayContaining([
              expect.objectContaining({
                name: 'OtherFaction',
                relationships: [
                  {
                    factionName: 'NewName',
                    relationshipType: RelationshipStanding.Ally,
                  },
                ],
              }),
            ]),
          })
        );
      });

      it('should return null when new faction name already exists', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [
            { name: 'ExistingFaction', description: 'Test' },
            { name: 'AnotherFaction', description: 'Test2' },
          ],
          version: '1.0',
        });

        const result = await updateFaction('ExistingFaction', {
          name: 'AnotherFaction',
        });

        expect(result).toBeNull();
      });

      it('should handle removed relationships by removing reciprocals', async () => {
        const faction1 = {
          name: 'Faction1',
          description: 'Test',
          relationships: [
            { factionName: 'Faction2', relationshipType: 'Ally' },
          ],
        };
        const faction2 = {
          name: 'Faction2',
          description: 'Test',
          relationships: [
            { factionName: 'Faction1', relationshipType: 'Ally' },
          ],
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [faction1, faction2],
          version: '1.0',
        });

        await updateFaction('Faction1', { relationships: [] });

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_factions',
          expect.objectContaining({
            factions: expect.arrayContaining([
              expect.objectContaining({
                name: 'Faction2',
                relationships: [],
              }),
            ]),
          })
        );
      });

      it('should handle added relationships by creating reciprocals', async () => {
        const faction1 = {
          name: 'Faction1',
          description: 'Test',
          relationships: [],
        };
        const faction2 = {
          name: 'Faction2',
          description: 'Test',
          relationships: [],
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [faction1, faction2],
          version: '1.0',
        });

        await updateFaction('Faction1', {
          relationships: [
            {
              factionName: 'Faction2',
              relationshipType: RelationshipStanding.Enemy,
            },
          ],
        });

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_factions',
          expect.objectContaining({
            factions: expect.arrayContaining([
              expect.objectContaining({
                name: 'Faction2',
                relationships: [
                  {
                    factionName: 'Faction1',
                    relationshipType: RelationshipStanding.Enemy,
                  },
                ],
              }),
            ]),
          })
        );
      });

      it('should handle changed relationship types by updating reciprocals', async () => {
        const faction1 = {
          name: 'Faction1',
          description: 'Test',
          relationships: [
            {
              factionName: 'Faction2',
              relationshipType: RelationshipStanding.Ally,
            },
          ],
        };
        const faction2 = {
          name: 'Faction2',
          description: 'Test',
          relationships: [
            {
              factionName: 'Faction1',
              relationshipType: RelationshipStanding.Ally,
            },
          ],
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [faction1, faction2],
          version: '1.0',
        });

        await updateFaction('Faction1', {
          relationships: [
            {
              factionName: 'Faction2',
              relationshipType: RelationshipStanding.Enemy,
            },
          ],
        });

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_factions',
          expect.objectContaining({
            factions: expect.arrayContaining([
              expect.objectContaining({
                name: 'Faction2',
                relationships: [
                  { factionName: 'Faction1', relationshipType: 'Enemy' },
                ],
              }),
            ]),
          })
        );
      });
    });

    describe('toggleFactionRetired', () => {
      it('should toggle faction retired status', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [{ name: 'TestFaction', retired: false }],
          version: '1.0',
        });

        const result = await toggleFactionRetired('TestFaction');

        expect(result).toBe(true);
        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_factions',
          expect.objectContaining({
            factions: [
              expect.objectContaining({
                name: 'TestFaction',
                retired: true,
              }),
            ],
          })
        );
      });

      it('should return false for non-existent faction', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          factions: [],
          version: '1.0',
        });

        const result = await toggleFactionRetired('NonExistent');

        expect(result).toBe(false);
      });
    });

    describe('migrateFactionDescriptions', () => {
      it('should migrate faction descriptions from characters to centralized storage', async () => {
        const character: GameCharacter = {
          id: 'char-1',
          name: 'Test',
          species: 'Human',
          perkIds: [],
          distinctionIds: [],
          factions: [
            {
              name: 'Brotherhood',
              standing: RelationshipStanding.Ally,
              description: 'A powerful faction from character data',
            },
          ],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock)
          .mockResolvedValueOnce({
            characters: [character],
            version: '1.0',
            lastUpdated: mockDate,
          })
          .mockResolvedValueOnce({ factions: [], version: '1.0' });

        await migrateFactionDescriptions();

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_factions',
          expect.objectContaining({
            factions: [
              expect.objectContaining({
                name: 'Brotherhood',
                description: 'A powerful faction from character data',
              }),
            ],
          })
        );
      });

      it('should not overwrite existing faction descriptions', async () => {
        const character: GameCharacter = {
          id: 'char-1',
          name: 'Test',
          species: 'Human',
          perkIds: [],
          distinctionIds: [],
          factions: [
            {
              name: 'Brotherhood',
              standing: RelationshipStanding.Ally,
              description: 'From character',
            },
          ],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock)
          .mockResolvedValueOnce({
            characters: [character],
            version: '1.0',
            lastUpdated: mockDate,
          })
          .mockResolvedValueOnce({
            factions: [
              {
                name: 'Brotherhood',
                description: 'Existing description',
              },
            ],
            version: '1.0',
          });

        await migrateFactionDescriptions();

        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager_factions',
          expect.objectContaining({
            factions: [
              expect.objectContaining({
                name: 'Brotherhood',
                description: 'Existing description',
              }),
            ],
          })
        );
      });
    });

    describe('Location Management Advanced', () => {
      it('should return null when creating location with duplicate name', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockResolvedValue({
          locations: [
            { id: 'loc-1', name: 'Existing Location', description: 'Test' },
          ],
          version: '1.0',
        });

        const result = await createLocation({
          name: 'Existing Location',
          description: 'Duplicate',
        });

        expect(result).toBeNull();
      });

      it('should delete location and remove references from characters', async () => {
        const character: GameCharacter = {
          id: 'char-1',
          name: 'Test',
          species: 'Human',
          locationId: 'loc-to-delete',
          perkIds: [],
          distinctionIds: [],
          factions: [],
          relationships: [],
          present: false,
          retired: false,
          createdAt: mockDate,
          updatedAt: mockDate,
        };

        (SafeAsyncStorageJSONParser.getItem as jest.Mock)
          .mockResolvedValueOnce({
            characters: [character],
            version: '1.0',
            lastUpdated: mockDate,
          })
          .mockResolvedValueOnce({
            locations: [
              { id: 'loc-to-delete', name: 'ToDelete', description: 'Test' },
            ],
            version: '1.0',
          });

        const result = await deleteLocationCompletely('loc-to-delete');

        expect(result.success).toBe(true);
        expect(result.charactersUpdated).toBe(1);
        expect(SafeAsyncStorageJSONParser.setItem).toHaveBeenCalledWith(
          'gameCharacterManager',
          expect.objectContaining({
            characters: [
              expect.objectContaining({
                locationId: undefined,
              }),
            ],
          })
        );
      });

      it('should return error when deleteLocationCompletely fails', async () => {
        (SafeAsyncStorageJSONParser.getItem as jest.Mock).mockRejectedValue(
          new Error('Storage error')
        );

        const result = await deleteLocationCompletely('loc-id');

        expect(result.success).toBe(false);
        expect(result.charactersUpdated).toBe(0);
      });
    });
  });
});
